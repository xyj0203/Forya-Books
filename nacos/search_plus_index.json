{"./":{"url":"./","title":"Introduction","keywords":"","body":"写作背景本书简介写作背景 这本书是本人写的第一本gitbook书，大概耗费一个下午 将gitbook给安装。因为最近在研究nacos这个配置分发和注册中心，所以就想以此为题写一本书。希望之后的自己看到后，能够专心的把这本书给写出。 希望本书的写作内容，能给后来者一些启发，本书不仅仅是包含内容干活，更是面向个人的学习习惯触发。因为观念不同，可能我们看框架的视角不同，可做参考，但不可作为依赖。 本书基于Nacos2.2.3进行编写，如有错误的地方欢迎指正。 本书简介 首先，我们学习一门技术最好的方案就是从官方网站开始，下面是nacos的官方网站。 其中包含了其基本的介绍和与其它项目的集成,接下来我们将会从基本的概念和架构开始，先进行了解其基本的作用和实现，再与其他项目集成，最后我们再深挖源码，下面就开始我们的学习之旅把！ "},"Chapter1/Chapter1.1.html":{"url":"Chapter1/Chapter1.1.html","title":"1.1 什么是nacos","keywords":"","body":"1.1 什么是nacos?1.1 什么是nacos? 一门技术的兴起一定会有它自己独特的功能，正如缓存、数据库、消息队列等一系列的中间件一样，nacos也有它自己独特的起源。 nacos主要是阿里的开源产品，伴随的是阿里的生产实践以及借鉴其他的注册中心而有的孵化品，在官网上我们可以看到有篇关于阿里巴巴服务注册中心产品的发展回顾，《阿里巴巴服务注册中心产品ConfigServer 10年技术发展回顾》，这篇文档的大概意思是在阿里的业务拓展下，最初的服务注册发现产品Eureka不再符合阿里的业务，于是在2018年左右，阿里开始了自研服务注册中心的道路，最开始也是借鉴Eureka的设计理念，往后推进时也添加上了一些自己的思考和阿里线上的具体实践，一步步的迭代，从最初的SDK，到单机版，再到集群一步步的解决了服务注册发现方面的一些问题，然后就形成了我们今天所看到的从ConfigServer进化而来的nacos。 在分布式系统中，有三个特性一致性、可用性、分区容错性，而注册中心必然处于分布式系统中，那么它必然要满足CAP原则。而Eureka和ConfigServer则是同属于AP类型的注册中心，他们两个在之后的业务拓展中拥有着相似的阻碍，而阿里巴巴则将ConfigServer的技术架构和生产环境的发现融合到了开源产品nacos中，继往开来在云原生、微服务的时代继续着发光发热。 "},"Chapter1/Chapter1.2.html":{"url":"Chapter1/Chapter1.2.html","title":"1.2 nacos的功能和生态","keywords":"","body":"1.2 nacos功能和生态1.2.1 特性1.2.2 生态上一节我们讨论了nacos的发展及一些基本的注册中心知识，这一节我们将对于它的功能和生态进行进一步的探讨。 1.2 nacos功能和生态 对于我们学习技术来说，最重要的就是这门新的技术有什么样的功能，和他的生态是否强大。功能决定了它的业务适用性，任何的技术都是为业务而生。而生态则是技术的后备支持，比如说漏洞维护，功能新增等一系列的技术支持。很显然Nacos是阿里巴巴的产品，而且可以与多种技术进行集成，由此决定了它在微服务中的适用性。 1.2.1 特性 nacos的官网是这么说的，它是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 1、服务发现和服务健康检测 服务发现和服务健康检测基本上是每一个注册中心都需要进行保证的功能。Nacos采用的是基于DNS和RPC的服务发现。支持传输层层面的健康检测，也就是我们常用的ping命令或者tcp的一系列指令，同时也迟迟应用层自定义的健康检查。 对于复杂的云环境还提供了agent 上报模式和服务端主动检测2种健康检查模式。 2、动态配置服务 动态配置可以让我们的配置文件中心化、外部化和动态化的管理所有环境的应用配置和服务配置，可以更加方便的管理服务，让服务进行弹性的拓展更加的简单。换句话说就是我们的配置文件不再由应用管理，而是交由一个中心化的应用进行管理，方便了配置文件的更改和版本追踪，最终还是服务于应用。 3、动态DNS服务（DDNS） 通过支持权重路由，动态DNS服务能让您轻松实现中间层负载均衡、更灵活的路由策略、流量控制以及简单数据中心内网的简单DNS解析服务。动态DNS服务还能让您更容易地实现以DNS协议为基础的服务发现，以消除耦合到厂商私有服务发现API上的风险。 4、服务及其元数据管理 Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。 1.2.2 生态 nacos的生态十分强大，它可以很方便的与一些第三方框架进行集成，具体的在此不再阐述，之后会在项目中进行一一的展现。而在此我想说的是，对于一个服务的生态，我们需要关心的是这个技术的使用方向以及使用的广度。 对于本书的nacos来说，他有非常多的使用方案，包括配置分发，服务发现等，因为背靠阿里巴巴这个巨大的生态圈，也使得它的更新迭代也是非常快的，我们在使用的初期仅需要去掌握使用即可，等到我们使用的次数多了，再去探讨核心功能的实现才是最好的‘食用方式‘。下图为Nacos的生态图： "},"Chapter1/Chapter1.3.html":{"url":"Chapter1/Chapter1.3.html","title":"1.3 nacos专业名词","keywords":"","body":"1.3 Nacos的专业名词1.3.1 地域1.3.2 可用区1.3.3 接入点1.3.4 命名空间1.3.5 配置1.3.6 配置管理1.3.7 配置项1.3.8 配置集1.3.9 配置集 ID1.3.10 配置分组1.3.11 配置快照1.3.12 服务1.3.13 服务名1.3.14 服务注册中心1.3.15 服务发现1.3.16 元信息1.3.17 应用1.3.18 服务分组1.3.19 虚拟集群1.3.20 实例1.3.21 权重1.3.22 健康检查1.3.23 健康保护阈值上一节我们说到了Nacos的一些特性和它的生态圈，如果不出意外的话，或者作者未来的几年依然在这个行业，一定会慢慢的把生态圈上的所有给更新完毕。接下来我们将要来学习下Nacos的一些专业术语 1.3 Nacos的专业名词 这一部分主要取自Nacos的官方文档，因为对于专业名词来说，官网给的才是最准确的，其中也添加上了一点自己的见解。 1.3.1 地域 物理的数据中心，资源创建成功之后就不能再次更换。 1.3.2 可用区 同一地域内，电力和网络互相独立的物理区域。同一可用区内，实例的网络延迟较低。 1.3.3 接入点 地域的某个服务的入口域名。 1.3.4 命名空间 用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。这个我们之后的使用会比较多，主要用于隔绝环境，方便我们在不同环境下的开发工作。 1.3.5 配置 在系统开发过程中，开发者通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成。配置变更是调整系统运行时的行为的有效手段。这里的配置文件有很多格式，text,yml,properties等，已经可以符合我们的日常配置文件的格式。 1.3.6 配置管理 主要是对上面的配置进行一系列的操作，后面我们会进行探讨其源码的具体实现。系统配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动。 1.3.7 配置项 一个具体的可配置的参数与其值域，通常以 param-key=param-value 的形式存在。例如我们常配置系统的日志输出级别（logLevel=INFO|WARN|ERROR） 就是一个配置项。 1.3.8 配置集 一组相关或者不相关的配置项的集合称为配置集。在系统中，一个配置文件通常就是一个配置集，包含了系统各个方面的配置。例如，一个配置集可能包含了数据源、线程池、日志级别等配置项。 1.3.9 配置集 ID Nacos 中的某个配置集的 ID。配置集 ID 是组织划分配置的维度之一。Data ID 通常用于组织划分系统的配置集。一个系统或者应用可以包含多个配置集，每个配置集都可以被一个有意义的名称标识。Data ID 通常采用类 Java 包（如 com.taobao.tc.refund.log.level）的命名规则保证全局唯一性。此命名规则非强制。 1.3.10 配置分组 Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串（如 Buy 或 Trade ）对配置集进行分组，从而区分 Data ID 相同的配置集。当您在 Nacos 上创建一个配置时，如果未填写配置分组的名称，则配置分组的名称默认采用 DEFAULT_GROUP 。配置分组的常见场景：不同的应用或组件使用了相同的配置类型，如 database_url 配置和 MQ_topic 配置。 1.3.11 配置快照 Nacos 的客户端 SDK 会在本地生成配置的快照。当客户端无法连接到 Nacos Server 时，可以使用配置快照显示系统的整体容灾能力。配置快照类似于 Git 中的本地 commit，也类似于缓存，会在适当的时机更新，但是并没有缓存过期（expiration）的概念。可以说是本地的缓存，用于缓解Nacos出现问题无法访问时可以生效，保证服务的正常运行。 1.3.12 服务 通过预定义接口网络访问的提供给客户端的软件功能。例如在大型网购系统中的订单系统、消费券系统、会员系统等。 1.3.13 服务名 服务提供的标识，通过该标识可以唯一确定其指代的服务。 1.3.14 服务注册中心 存储服务实例和服务负载均衡策略的数据库，可以将自己自身的服务信息提交到注册中心，其他的服务模块想要调用时则可以进行注册中心寻找调用的信息，注册中心也可以在此时做一层负载均衡，将请求分发到算力充足或者业务不是很繁忙的服务上面去。 1.3.15 服务发现 在计算机网络上，（通常使用服务名）对服务下的实例的地址和元数据进行探测，并以预先定义的接口提供给客户端进行查询。 1.3.16 元信息 Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略、鉴权配置、各种自定义标签 (label)，从作用范围来看，分为服务级别的元信息、集群的元信息及实例的元信息。 1.3.17 应用 用于标识服务提供方的服务的属性。 1.3.18 服务分组 不同的服务可以归类到同一分组. 1.3.19 虚拟集群 同一个服务下的所有服务实例组成一个默认集群, 集群可以被进一步按需求划分，划分的单位可以是虚拟集群。 1.3.20 实例 提供一个或多个服务的具有可访问网络地址（IP:Port）的进程。 1.3.21 权重 实例级别的配置。权重为浮点数。权重越大，分配给该实例的流量越大。 1.3.22 健康检查 以指定方式检查服务下挂载的实例 (Instance) 的健康度，从而确认该实例 (Instance) 是否能提供服务。根据检查结果，实例 (Instance) 会被判断为健康或不健康。对服务发起解析请求时，不健康的实例 (Instance) 不会返回给客户端。 1.3.23 健康保护阈值 为了防止因过多实例 (Instance) 不健康导致流量全部流向健康实例 (Instance) ，继而造成流量压力把健康实例 (Instance) 压垮并形成雪崩效应，应将健康保护阈值定义为一个 0 到 1 之间的浮点数。当域名健康实例数 (Instance) 占总服务实例数 (Instance) 的比例小于该值时，无论实例 (Instance) 是否健康，都会将这个实例 (Instance) 返回给客户端。这样做虽然损失了一部分流量，但是保证了集群中剩余健康实例 (Instance) 能正常工作。 "},"Chapter1/Chapter1.4.html":{"url":"Chapter1/Chapter1.4.html","title":"1.4 nacos架构","keywords":"","body":"1.4 Nacos架构上一节我们着重的了解了下Nacos的一些官方名词，接下来我们将继续深入Nacos的架构继续探讨。这时可能有人会疑惑了，为什么架构这么重要的部分只介绍了一节，因为官网已经给了一本300多页的书来讲Nacos的架构，产品的开发人员肯定比我更加的了解技术架构，所以在此就不再过多的阐述，就大概的讲述一下我对于软件架构的学习方法。 1.4 Nacos架构 对于一门技术的架构的话，我们如果学习，还是需要从官方入手，如果是比较火的技术，官方一般都会出一个文档关于研发这个软件的过程，以及致力于解决什么问题。 如上图所示，这本书是由阿里出的，所以内容也不会太差，我们在学习的初期，一般是不会太多的去关注架构。大概是在使用之后，我们需要对于开源软件有我们自己的DIY时才会去关注软件的架构，然后对于模块进行魔改，然后进行内测上线。 《Nacos架构&原理》 "},"Chapter1/Chapter1.5.html":{"url":"Chapter1/Chapter1.5.html","title":"1.5 nacos的安装启动","keywords":"","body":"1.5 Nacos的安装和启动1.5.1 单机部署启动1.5.2 docker部署启动这一节我们来探讨一下软件的安装和启动，在我们之前的学习中，我们可能倾向于去将手动下载，然后解压安装，但是随着技术的迭代，越来越多的虚拟技术的出现使得软件安装部署也有了新的花样。 假如我们来假设这样一个场景，我们需要部署一个集群，这样的话如果是在我们自己测试的环境还好说，通过暴力进行解决，或者说也可以通过写一个shell脚本进行，但是如果说是在不同的主机上，这样就会变得很麻烦，于是乎就有了Docker,k8s等一系列的实现方案，我们可以在虚拟的容器内进行部署，然后也可以动态的进行上线下线的控制。对于Docker的学习还是有一定的必要的，之后可以了解一下这里只是简单的介绍一下之后的软件安装模式。 1.5 Nacos的安装和启动 我们这部分还是根据Nacos的官网来进行，有什么需要注意的细节我会一一的点明。 因为Nacos是基于JAVA实现的，所以最基础的要JAVA的环境，这一点是必不可少的，一下的安装都基于Linux完成，原因的话可以下去自己去了解。 1.5.1 单机部署启动 我们就从最基础的开始安装，只演示一次，之后我们会只使用docker安装。因为学到这里就已经默认已经具备独立安装JDK的条件了，我们主要来进行安装Nacos。 首先我们要先下载适合我们的软件包，下载地址我们一般是在github上找稳定的版本，我选择的是最新的 Nacos，选择第一个进行下载。 下载成功后，我们将其上传至Linux中，也可以通过linux的curl命令下载，但是一般很慢不建议。 #解压 tar -zxvf nacos-server-2.2.3.tar.gz nacos 修改配置，nacos的配置是在application.properties中 #*************** Spring Boot Related Configurations ***************# #这些一般用默认的就可以 ### Default web context path: server.servlet.contextPath=/nacos ### Include message field server.error.include-message=ALWAYS ### Default web server port: server.port=8848 #*************** Network Related Configurations ***************# ### If prefer hostname over ip for Nacos server addresses in cluster.conf: # nacos.inetutils.prefer-hostname-over-ip=false ### Specify local server's IP: # nacos.inetutils.ip-address= #*************** Config Module Related Configurations ***************# ### If use MySQL as datasource: ### Deprecated configuration property, it is recommended to use `spring.sql.init.platform` replaced. # spring.datasource.platform=mysql # spring.sql.init.platform=mysql ### Count of DB: # db.num=1 #数据库的配置，我就用我本机的mysql，也不再进行安装了 db.url.0=jdbc:mysql://10.102.46.60:3306/nacos?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC db.user.0=root db.password.0=123456 ### Connection pool configuration: hikariCP db.pool.config.connectionTimeout=30000 db.pool.config.validationTimeout=10000 db.pool.config.maximumPoolSize=20 db.pool.config.minimumIdle=2 #*************** Naming Module Related Configurations ***************# ### If enable data warmup. If set to false, the server would accept request without local data preparation: # nacos.naming.data.warmup=true ### If enable the instance auto expiration, kind like of health check of instance: # nacos.naming.expireInstance=true ### Add in 2.0.0 ### The interval to clean empty service, unit: milliseconds. # nacos.naming.clean.empty-service.interval=60000 ### The expired time to clean empty service, unit: milliseconds. # nacos.naming.clean.empty-service.expired-time=60000 ### The interval to clean expired metadata, unit: milliseconds. # nacos.naming.clean.expired-metadata.interval=5000 ### The expired time to clean metadata, unit: milliseconds. # nacos.naming.clean.expired-metadata.expired-time=60000 ### The delay time before push task to execute from service changed, unit: milliseconds. # nacos.naming.push.pushTaskDelay=500 ### The timeout for push task execute, unit: milliseconds. # nacos.naming.push.pushTaskTimeout=5000 ### The delay time for retrying failed push task, unit: milliseconds. # nacos.naming.push.pushTaskRetryDelay=1000 ### Since 2.0.3 ### The expired time for inactive client, unit: milliseconds. # nacos.naming.client.expired.time=180000 #*************** CMDB Module Related Configurations ***************# ### The interval to dump external CMDB in seconds: # nacos.cmdb.dumpTaskInterval=3600 ### The interval of polling data change event in seconds: # nacos.cmdb.eventTaskInterval=10 ### The interval of loading labels in seconds: # nacos.cmdb.labelTaskInterval=300 ### If turn on data loading task: # nacos.cmdb.loadDataAtStart=false #*************** Metrics Related Configurations ***************# ### Metrics for prometheus #management.endpoints.web.exposure.include=* ### Metrics for elastic search management.metrics.export.elastic.enabled=false #management.metrics.export.elastic.host=http://localhost:9200 ### Metrics for influx management.metrics.export.influx.enabled=false #management.metrics.export.influx.db=springboot #management.metrics.export.influx.uri=http://localhost:8086 #management.metrics.export.influx.auto-create-db=true #management.metrics.export.influx.consistency=one #management.metrics.export.influx.compressed=true #*************** Access Log Related Configurations ***************# ### If turn on the access log: server.tomcat.accesslog.enabled=true ### The access log pattern: server.tomcat.accesslog.pattern=%h %l %u %t \"%r\" %s %b %D %{User-Agent}i %{Request-Source}i ### The directory of access log: server.tomcat.basedir=file:. #*************** Access Control Related Configurations ***************# ### If enable spring security, this option is deprecated in 1.2.0: #spring.security.enabled=false ### The ignore urls of auth nacos.security.ignore.urls=/,/error,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-ui/public/**,/v1/auth/**,/v1/console/health/**,/actuator/**,/v1/console/server/** ### The auth system to use, currently only 'nacos' and 'ldap' is supported: nacos.core.auth.system.type=nacos ### If turn on auth system: nacos.core.auth.enabled=false ### Turn on/off caching of auth information. By turning on this switch, the update of auth information would have a 15 seconds delay. nacos.core.auth.caching.enabled=true ### Since 1.4.1, Turn on/off white auth for user-agent: nacos-server, only for upgrade from old version. nacos.core.auth.enable.userAgentAuthWhite=false ### Since 1.4.1, worked when nacos.core.auth.enabled=true and nacos.core.auth.enable.userAgentAuthWhite=false. ### The two properties is the white list for auth and used by identity the request from other server. nacos.core.auth.server.identity.key= nacos.core.auth.server.identity.value= ### worked when nacos.core.auth.system.type=nacos ### The token expiration in seconds: nacos.core.auth.plugin.nacos.token.cache.enable=false nacos.core.auth.plugin.nacos.token.expire.seconds=18000 ### The default token (Base64 String): nacos.core.auth.plugin.nacos.token.secret.key= ### worked when nacos.core.auth.system.type=ldap，{0} is Placeholder,replace login username #nacos.core.auth.ldap.url=ldap://localhost:389 #nacos.core.auth.ldap.basedc=dc=example,dc=org #nacos.core.auth.ldap.userDn=cn=admin,${nacos.core.auth.ldap.basedc} #nacos.core.auth.ldap.password=admin #nacos.core.auth.ldap.userdn=cn={0},dc=example,dc=org #nacos.core.auth.ldap.filter.prefix=uid #nacos.core.auth.ldap.case.sensitive=true #*************** Istio Related Configurations ***************# ### If turn on the MCP server: nacos.istio.mcp.server.enabled=false #*************** Core Related Configurations ***************# ### set the WorkerID manually # nacos.core.snowflake.worker-id= ### Member-MetaData # nacos.core.member.meta.site= # nacos.core.member.meta.adweight= # nacos.core.member.meta.weight= ### MemberLookup ### Addressing pattern category, If set, the priority is highest # nacos.core.member.lookup.type=[file,address-server] ## Set the cluster list with a configuration file or command-line argument # nacos.member.list=192.168.16.101:8847?raft_port=8807,192.168.16.101?raft_port=8808,192.168.16.101:8849?raft_port=8809 ## for AddressServerMemberLookup # Maximum number of retries to query the address server upon initialization # nacos.core.address-server.retry=5 ## Server domain name address of [address-server] mode # address.server.domain=jmenv.tbsite.net ## Server port of [address-server] mode # address.server.port=8080 ## Request address of [address-server] mode # address.server.url=/nacos/serverlist #*************** JRaft Related Configurations ***************# ### Sets the Raft cluster election timeout, default value is 5 second # nacos.core.protocol.raft.data.election_timeout_ms=5000 ### Sets the amount of time the Raft snapshot will execute periodically, default is 30 minute # nacos.core.protocol.raft.data.snapshot_interval_secs=30 ### raft internal worker threads # nacos.core.protocol.raft.data.core_thread_num=8 ### Number of threads required for raft business request processing # nacos.core.protocol.raft.data.cli_service_thread_num=4 ### raft linear read strategy. Safe linear reads are used by default, that is, the Leader tenure is confirmed by heartbeat # nacos.core.protocol.raft.data.read_index_type=ReadOnlySafe ### rpc request timeout, default 5 seconds # nacos.core.protocol.raft.data.rpc_request_timeout_ms=5000 #*************** Distro Related Configurations ***************# ### Distro data sync delay time, when sync task delayed, task will be merged for same data key. Default 1 second. # nacos.core.protocol.distro.data.sync.delayMs=1000 ### Distro data sync timeout for one sync data, default 3 seconds. # nacos.core.protocol.distro.data.sync.timeoutMs=3000 ### Distro data sync retry delay time when sync data failed or timeout, same behavior with delayMs, default 3 seconds. # nacos.core.protocol.distro.data.sync.retryDelayMs=3000 ### Distro data verify interval time, verify synced data whether expired for a interval. Default 5 seconds. # nacos.core.protocol.distro.data.verify.intervalMs=5000 ### Distro data verify timeout for one verify, default 3 seconds. # nacos.core.protocol.distro.data.verify.timeoutMs=3000 ### 加载快照数据失败时，分区数据加载重试的延迟时间，默认为 30 秒。 # nacos.core.protocol.distro.data.load.retryDelayMs=30000 ### 启用以支持 prometheus 服务发现 #nacos.prometheus.metrics.enabled=true ### Since 2.3 #*************** Grpc Configurations ***************# ## sdk grpc(between nacos server and client) configuration ## Sets the maximum message size allowed to be received on the server. #nacos.remote.server.grpc.sdk.max-inbound-message-size=10485760 ## 设置发送 keepalive ping 之前无读取活动的时间（毫秒）。典型的默认值是两小时。 #nacos.remote.server.grpc.sdk.keep-alive-time=7200000 ## 设置发送 keepalive ping 后等待读取活动的时间（毫秒）。默认为 20 秒。 #nacos.remote.server.grpc.sdk.keep-alive-timeout=20000 ## 设置时间（毫秒），指定允许客户端配置的最长保持连接时间。典型的默认值是 5 分钟 #nacos.remote.server.grpc.sdk.permit-keep-alive-time=300000 ## cluster grpc(inside the nacos server) configuration #nacos.remote.server.grpc.cluster.max-inbound-message-size=10485760 ## 设置发送 keepalive ping 之前无读取活动的时间（毫秒）。典型的默认值是两小时。 #nacos.remote.server.grpc.cluster.keep-alive-time=7200000 ## 设置发送 keepalive ping 后等待读取活动的时间（毫秒）。默认为 20 秒。 #nacos.remote.server.grpc.cluster.keep-alive-timeout=20000 ## 设置时间（毫秒），指定允许客户端配置的最长保持连接时间。典型的默认值是 5 分钟 #nacos.remote.server.grpc.cluster.permit-keep-alive-time=300000 我们一开始仅需关注权限认证和数据库配置的配置文件即可，后续的参数配置在使用时再进行探讨。接下来我们来进行启动nacos。我们先不开启认证，先进行体验，后续再进行开启认证。 如果启动过程中出现libstdc++.so.6: cannot open shared object file: No such file or directory，大概是共享库有所缺失，我们可以通过一位网友的做法来进行解决。解决方案 sh startup.sh -m standalone 启动成功，然后我们进行访问。 此时我们可以先自己进行稍微体验一下，再然后我们将开始docker部署。 1.5.2 docker部署启动 如果你学习过docker的话就会大概知道我们要安装一个应用的话需要先下载镜像，然后通过镜像来进行容器的获取。dockerhub是一个可以下载镜像的网站，当然国内也有自己的镜像，你也可以选择自己搭一个镜像托管的网站或是自己写一个镜像(不推荐，毕竟前人已经实现了)，由于官网经常不能用，所以我们采用代理的方式来解决， dockerproxy,目前来说做的最好的集成代理。 当然国内也有响应的镜像，阿里云、网易云，我们先要进行搜索nacos的镜像，然后安装。 我们首先进入dockerhub的官方网站，然后去搜索我们要的镜像，一般来说，对于开源的软件都有已经构建好的镜像，我们不需要自己再去构建。 然后我们来搜索nacos 第一个就是我们需要的应用软件。 我们先去Tags中找到我们需要的版本往下看文档我们就会看到对应的启动命令，这里还是推荐先去大概的了解docker再来进行下面的安装步骤。 # 拉取镜像命令 docker pull nacos/nacos-server:v2.2.3 # 启动命令,因为在2.x版本后开启了grpc，所以我们还要开启9849端口 #1、不配置数据库的启动 docker run --name nacos-test1 -e MODE=standalone -p 8848:8848 -d nacos/nacos-server:v2.2.3 #2、配置数据库 docker run \\ --name nacos-test2 \\ -e MODE=standalone \\ -e SPRING_DATASOURCE_PLATFORM=mysql \\ -e MYSQL_SERVICE_HOST=10.102.46.60 \\ -e MYSQL_SERVICE_DB_NAME=nacos \\ -e MYSQL_SERVICE_USER=root \\ -e MYSQL_SERVICE_PASSWORD=123456 \\ -p 8848:8848 \\ -p 9848:9848 \\ -d nacos/nacos-server:v2.2.3 我们可以根据文档的下面的参数表格来书写我们想要的配置项，也可以执行docker命令进入容器内部进行修改，我比较推荐前者。 还有更方便的安装方式docker-compose,这里就不进行过多的阐述，读者可以下去自行了解，总的来说docker的功能十分强大，它还支持内部的分配ip和网段进行网络的划分，有必要去好好的学习一下，这里我推荐一下自己的入门书籍《Docker 一从入门到实践》，今天的介绍就到此为止。 "},"Chapter2/Chapter2.1.html":{"url":"Chapter2/Chapter2.1.html","title":"2.1 NacosClient","keywords":"","body":"2.1 NacosClient上一章我们大概了解了nacos的一些特性和基础的安装配置，下来我们将对于nacos的使用来进行讲解，对于我们来说一门技术的使用要么是对外进行提供SDK，要么是直接提供通信接口，最后便是与各种开发框架进行集成，nacos也不例外，他有着自己的client，也有和各种开源框架的集成。 我们的开发环境选择的IDEA，采用的nacos的版本为v2.2.3，因为我是根据nacos的官网开始的，所以我们可以跟随官网的例子，将步骤走一下，来领略下nacos的强大，以下的学习我们来通过nacos-example来进行学习和体验。 2.1 NacosClient 首先是我们需要引入nacos-client，这个是客户端SDK，我们需要导入maven坐标，我们采用JUNIT4来进行测试功能。 2.2.3 com.alibaba.nacos nacos-client ${nacos.version} 根据文档来看，我们在使用的时候需要先获取ConfigService，所以我们首先进行获取这个类，我们把它放在初始化的代码中，这样我们就可以在每一次启动的时候获取到ConfigService。我们首先需要创建dataId和groupId，如果有需要的话我们还可以新建一个namespace，主要用于配置文件的分组和隔离。 dataId一般是填写包名，保证配置文件的唯一性。 group一般是写产品名:模块名,为了区分不同模块的配置文件。 namespace一般是为了区分的不同的产品，也就是我们所说的项目。 下面是我创建的我自己的配置命名。 @Before public void init() throws NacosException { // nacos获取配置 String serverAddr = \"192.168.150.101:8848\"; Properties properties = new Properties(); properties.put(PropertyKeyConst.SERVER_ADDR, serverAddr); configService = NacosFactory.createConfigService(properties); } 然后我们在使用完毕的时候再进行关闭。 @After public void after() throws NacosException { configService.shutDown(); } 然后我们来进行测试功能，各项功能皆是根据文档来的，所以我们就直接统一的贴上代码，也没有什么需要其他的注意的点，需要注意的我们会在这一章的最后一节进行统一解释。 package org.example; import com.alibaba.nacos.api.NacosFactory; import com.alibaba.nacos.api.PropertyKeyConst; import com.alibaba.nacos.api.config.ConfigService; import com.alibaba.nacos.api.config.listener.Listener; import com.alibaba.nacos.api.exception.NacosException; import org.junit.After; import org.junit.Before; import org.junit.Test; import java.util.Properties; import java.util.concurrent.Executor; /** * @description: 测试nacos * @author: xuyujie * @date: 2023/09/24 **/ public class TestNacosConfig { ConfigService configService; String dataId = \"com.wojucai.nacos-client.application\"; String group = \"shop:order\"; long timeout = 3000; @Before public void init() throws NacosException { // nacos获取配置 String serverAddr = \"192.168.150.101:8848\"; Properties properties = new Properties(); properties.put(PropertyKeyConst.SERVER_ADDR, serverAddr); // 账号密码,配置auth后启用，后面会介绍 // properties.put(PropertyKeyConst.USERNAME, \"nacos\"); // properties.put(PropertyKeyConst.PASSWORD, \"nacos\"); // 命名空间 //properties.put(PropertyKeyConst.NAMESPACE, \"ccf91393-bf70-43ad-aa38-545d7df4a358\"); configService = NacosFactory.createConfigService(properties); } @After public void after() throws NacosException { configService.shutDown(); } /** * 测试发布 * 用于通过程序自动发布 Nacos 配置，以便通过自动化手段降低运维成本。 * 当配置不存在时会创建配置，当配置已存在时会更新配置。 * */ @Test public void testPublishConfig() throws NacosException { // dataId = \"com.wojucai.nacos-client.application2\"; // group = \"shop:order2\"; boolean yaml = configService.publishConfig(dataId, group, \"server:\\n\" + \" 8081\", \"yaml\"); System.out.println(yaml); } @Test public void testUpdateConfig() throws NacosException { boolean yaml = configService.publishConfig(dataId, group, \"server:\\n\" + \" 8083\", \"yaml\"); System.out.println(yaml); } /** * dataId string 配置 ID，采用类似 package.class（如com.taobao.tc.refund.log.level）的命名规则保证全局唯一性 * group string 配置分组，建议填写产品名:模块名（Nacos:Test）保证唯一性，只允许英文字符和4种特殊字符（\".\"、\":\"、\"-\"、\"_\"），不超过128字节。 * timeout long 读取配置超时时间，单位 ms，推荐值 3000。 * @throws NacosException */ @Test public void testGetConfig() throws NacosException { String config = configService.getConfig(dataId, group, timeout); System.out.println(config); } /** * dataId * string * 配置 ID，采用类似 package.class（如com.taobao.tc.refund.log.level）的命名规则保证全局唯一性，class 部分建议是配置的业务含义。 * group * string * 配置分组，建议填写产品名：模块名（如 Nacos:Test）保证唯一性。 * listener * Listener * 监听器，配置变更进入监听器的回调函数。 */ @Test public void testAddListener() throws NacosException { configService.addListener(dataId, group, new Listener() { @Override public Executor getExecutor() { return null; } @Override public void receiveConfigInfo(String s) { System.out.println(s); } }); // 移除监听器 // configService.removeListener(dataId, group, new Listener() { // @Override // public Executor getExecutor() { // return null; // } // // @Override // public void receiveConfigInfo(String s) { // System.out.println(s); // } // }); // 守护线程 while (true) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } // 取消监听 } /** * 用于通过程序自动删除 Nacos 配置 */ @Test public void testRemoveConfig() throws NacosException { boolean removeConfig = configService.removeConfig(dataId, group); System.out.println(removeConfig); } } 上面是一些基本的和配置文件相关的使用，下面我们来看一下服务发现注册的api。 这里有几个比较重要的实例对象Cluster、Instance和Service。 我们先来看Cluster public class Cluster implements Serializable { /** * 序列化ID */ private static final long serialVersionUID = -7196138840047197271L; /** * 属于的服务的名字 */ private String serviceName; /** * 集群名 */ private String name; /** * 集群的健康检查 */ private AbstractHealthChecker healthChecker = new Tcp(); /** * 在集群中注册的默认端口号 */ private int defaultPort = 80; /** *在集群中默认健康检查的端口 */ private int defaultCheckPort = 80; /** * 是否使用实例的端口坐健康检查 */ private boolean useIPPort4Check = true; /** * 元数据 */ private Map metadata = new HashMap<>(); } 然后我们再来看一下Instance public class Instance implements Serializable { private static final long serialVersionUID = -742906310567291979L; /** * 实例ID */ private String instanceId; /** * 实例的IP */ private String ip; /** * 实例的端口号 */ private int port; /** * 实例的权重 */ private double weight = 1.0D; /** * 实例的健康状态 */ private boolean healthy = true; /** * 实例是否接收请求 */ private boolean enabled = true; /** * 是否是短暂的实例 * * @since 1.0.0 */ private boolean ephemeral = true; /** * 实例的集群名 */ private String clusterName; /** * 实例的服务名 */ private String serviceName; /** * 元数据 */ private Map metadata = new HashMap<>(); } 然后我们来看一下Service这个类 /** * 我们引入了一个 \"服务-->集群-->实例 \"模型， * 其中服务存储了一个集群列表，而集群则包含一个实例列表。 */ public class Service implements Serializable { private static final long serialVersionUID = -3470985546826874460L; /** * 服务名 */ private String name; /** * 保护阈值 */ private float protectThreshold = 0.0F; /** * 这个服务的应用名 */ private String appName; /** * 服务分组名，用于将服务分为不同的组。 */ private String groupName; /** * 元数据 */ private Map metadata = new HashMap<>(); } 我们先来注册一个服务，然后注册集群，然后注册群组，来体验一下不同的api。 然后就是我们测试的全部代码 /** * @description:测试nacos服务 * @author: xuyujie * @date: 2023/09/24 **/ public class TestNacosService { NamingService namingService; NamingMaintainService maintainService; String appName = \"shop\"; String serviceName = \"order-service\"; String groupName = \"MQ_topic\"; @Before public void init() throws NacosException { String serverAddr = \"192.168.150.101:8848\"; Properties properties = new Properties(); properties.put(PropertyKeyConst.SERVER_ADDR, serverAddr); // properties.put(PropertyKeyConst.USERNAME, \"nacos\"); // properties.put(PropertyKeyConst.PASSWORD, \"nacos\"); // properties.put(PropertyKeyConst.NAMESPACE, \"ccf91393-bf70-43ad-aa38-545d7df4a358\"); namingService = NacosFactory.createNamingService(properties); maintainService = NacosFactory.createMaintainService(properties); } /** * 创建服务 */ @Test public void testRegisterInstance2() throws NacosException { // 注册服务 Service service = new Service(); service.setAppName(appName); service.setName(serviceName); service.setGroupName(groupName); service.setProtectThreshold(1); Map serviceMetadata = new HashMap<>(); service.setMetadata(serviceMetadata); maintainService.createService(service, new NoneSelector()); Service service1 = maintainService.queryService(\"order-service\", \"MQ_topic\"); System.out.println(service1); // 保证服务是在线状态 while (true) { } } /** * 创建集群 */ @Test public void testRegisterCluster() throws NacosException { Map serviceMetadata = new HashMap<>(); // 注册实例到集群 namingService.registerInstance(serviceName+1,groupName,\"11.11.11.11\",80, \"order-service-cluster\"); // 保证服务是在线状态 while (true) { } } /** * 注册实例 */ @Test public void testRegisterInstance() throws NacosException { Map serviceMetadata = new HashMap<>(); // 注册实例到集群 namingService.registerInstance(serviceName+1,groupName,\"11.11.11.11\",80); // 保证服务是在线状态 while (true) { } } } 要注意在注册的时候要保证线程是存活状态，只有线程存活，对应的nacos上的实例才会存活。如我现在启动两个线程，对应的nacos是如下图。 当我把服务关闭时，又会变成下图 以上便是我们这节测试它的一些Client功能。 "},"Chapter2/Chapter2.2.html":{"url":"Chapter2/Chapter2.2.html","title":"2.2 Nacos集成Spring","keywords":"","body":"2.2 Nacos集成Spring2.2.1Nacos配置数据库2.2.2Spring配置注发布到Nacos2.2.3Spring集成nacos实现配置监听2.2.4Spring集成多数据项配置2.2 Nacos集成Spring 下面我将对于nacos集成Spring来做进一步的学习，我们来进行参照Nacos官方给的example来继续学习。 2.2.1Nacos配置数据库 这个项目是nacos-spring-example的一个子项目，主要用于使用nacos来配置数据库，在WEB-INF文件夹下也有所有的配置文件，这是spring-web的基本的配置文件，我们大概来一个个了解下 首先是datasource.xml，主要用于配置和数据库相关的属性。 然后是dispatcher-servlet.xml 再然后是nacos.xml spring-config-mybatis.xml web.xml dispatcher org.springframework.web.servlet.DispatcherServlet 1 dispatcher / 如果我们不配置直接进行启动就会报错，如下图： 按照提示我们需要在控制台添加配置,我们添加下配置，然后来看效果。 启动成功，说明我们的应用已经从nacos上拉取下来了配置文件。 查询到了数据库中的值。 以上便是Spring和nacos集成实现的最基本的拉取配置的实例。 2.2.2Spring配置注发布到Nacos Spring的应用程序本身也是向外提供服务的，所以它也可以作为一个实例将配置文件发布到到nacos中，供其他应用程序进行调用。接下来我们要接触的实例是nacos-spring-config-example。 配置文件基本和上一部分无异，我们主要关注如何把这个服务给注册到Nacos中。 奥妙就在于NacosConfiguration这个类，我们需要通过这个类来向nacos发布配置。 // 保证这个类为Spring的配置类， 可以被Spring管理。 @Configuration // nacos的服务器的一系列配置项 @EnableNacosConfig(globalProperties = @NacosProperties(serverAddr = \"192.168.150.101:8848\")) /** * Document: https://nacos.io/zh-cn/docs/quick-start-spring.html * * Nacos 控制台添加配置： * * Data ID：example * * Group：DEFAULT_GROUP * * 配置内容：useLocalCache=true */ // 配置属性所属的数据源 @NacosPropertySource(dataId = \"example\", autoRefreshed = true) public class NacosConfiguration { } 然后就是控制属性的类了 // 声明控制器 @Controller @RequestMapping(\"config\") public class ConfigController { // 注入nacos的配置服务，主要用于向nacos进行发布配置 @NacosInjected private ConfigService configService; // 监听nacos的值， 如果更新的话也可以自动更新 @NacosValue(value = \"${useLocalCache:false}\", autoRefreshed = true) private boolean useLocalCache; // 获取值 @RequestMapping(value = \"/get\", method = GET) @ResponseBody public boolean get() { return useLocalCache; } // 向nacos发布配置 @RequestMapping(method = POST) @ResponseBody public ResponseEntity publish(@RequestParam String dataId, @RequestParam(defaultValue = \"DEFAULT_GROUP\") String group, @RequestParam String content) { boolean result = false; try { result = configService.publishConfig(dataId, group, content); } catch (NacosException e) { return new ResponseEntity(\"Publish Fail:\" + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR); } if (result) { return new ResponseEntity(\"Publish Success\", HttpStatus.OK); } return new ResponseEntity(\"Publish Fail, Retry\", HttpStatus.INTERNAL_SERVER_ERROR); } } 我们将容器启动后，发现访问后返回的是false，这是因为它具有默认值，然后我们按照上文指定的DataId去修改并发布配置，我们会发现一个新的世界。 然后我们来使用api工具来测试下发布配置，我们来把它重新改为false。 可以看到发布成功，那我们就不再看具体的结果了。总结就是，我们可以通过注解@EnableNacosConfig(globalProperties = @NacosProperties(serverAddr = \"192.168.150.101:8848\")) 来进行配置nacos的服务器属性，然后他就能和nacos服务器通信了，然后我们通过@NacosPropertySource(dataId = \"example\", autoRefreshed = true) 为对应的配置类绑定dataId因为dataId是唯一的，当然我们还可以配置group等，具体的属性可以自己去观看对应的注解类。 然后我们使用@NacosInjected来注入ConfigService用于发布配置，使用@NacosValue来绑定属性对应的配置值。 2.2.3Spring集成nacos实现配置监听 首先就是配置文件，对于这个项目来说的话，配置文件也是只有web.xml和dispatcherServlet-servlet.xml两个文件，基本与上述配置无异，这里是讲述监听这个模块的，我们着重的来看一下如何实现监听。 和上面的一样要先配置对应的注册中心服务器的地址。 @Configuration @EnableNacosConfig(globalProperties = @NacosProperties(serverAddr = \"192.168.150.101:8848\")) public class AdminConfiguration { } // 实现服务监听的类 @Service public class AdminServiceImpl implements AdminService { private static final Logger LOGGER = LoggerFactory.getLogger(AdminServiceImpl.class); // dataId private static final String ADMIN_DATA_ID = \"admin.json\"; // groupId private static final String ADMIN_GROUP_ID = \"spring-listener\"; private volatile Admin admin; // 这个用于监听，获取json的数据的值 @NacosConfigListener(dataId = ADMIN_DATA_ID, groupId = ADMIN_GROUP_ID) public void onReceived(String content) { LOGGER.info(\"onReceived(String) : {}\", content); } /** * * Nacos 控制台添加配置： * * Data ID：admin.json * * Group：spring-listener * * 配置内容： * { * \"username\": \"admin\", * \"password\": \"123456\" * } */ // 可以直接转化为JSON @NacosConfigListener(dataId = ADMIN_DATA_ID, groupId = ADMIN_GROUP_ID, converter = AdminConverter.class) public void onReceived(Admin admin) { LOGGER.info(\"onReceived(Admin) : {}\", admin); this.admin = admin; } @Override public Admin getAdmin() { return admin; } } 我们来向nacos的页面添加json数据，然后来看看是否可以反序列化为JAVA对象。 可以获取到值，然后我们再来看一下控制台是否有监听的内容： 这里也有，由此我们便知道了配置绑定的作用，可以实时的刷新配置文件。 这个配置监听主要有两点： 其一是注解@NacosConfigListener(dataId = ADMIN_DATA_ID, groupId = ADMIN_GROUP_ID, converter = AdminConverter.class)，用于声明监听器，以及转化对象，由此便可以进行对应的监听了。 其二是对应的JAVA对象必须是volatile修饰的，因为这样的话，一旦值被修改就会马上刷新到主内存中，从而保证配置是最新的配置。 2.2.4Spring集成多数据项配置 在上面我们只是简单的对于单个数据进行了配置，下来我们将了解一下多数据配置。nacos-spring-config-multi-data-ids-example用于集成了数据库和缓存Redis的用法。 首先它的配置没有多大的变更，依然是dispacherServlet-servlet.xml,web.xml,cache.xml,datasource.xml。 这次的话我们需要在控制台上配备多个数据。 主要的作用类是NacosConfiguration，这个类用于实现多个配置注册。 package com.alibaba.nacos.example.spring; import com.alibaba.nacos.api.annotation.NacosProperties; import com.alibaba.nacos.spring.context.annotation.config.EnableNacosConfig; import com.alibaba.nacos.spring.context.annotation.config.NacosPropertySource; import com.alibaba.nacos.spring.context.annotation.config.NacosPropertySources; import org.springframework.context.annotation.Configuration; @Configuration @EnableNacosConfig(globalProperties = @NacosProperties(serverAddr = \"192.168.150.101:8848\")) @NacosPropertySources({ /* * Nacos 控制台添加配置： * Data ID：app.properties * Group：multi-data-ids * 配置内容：app.user.cache=false */ @NacosPropertySource(dataId = \"app.properties\", groupId = \"multi-data-ids\", autoRefreshed = true), /* * 1. 本地安装 MySQL * 2. Nacos 控制台添加配置： * Data ID：datasource.properties * Group：multi-data-ids * 配置内容示例： * spring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false * spring.datasource.username=root * spring.datasource.password=root * spring.datasource.initial-size=10 * spring.datasource.max-active=20 */ @NacosPropertySource(dataId = \"datasource.properties\", groupId = \"multi-data-ids\"), /* * 1. 本地安装 Redis * 2. Nacos 控制台添加配置： * Data ID：redis.properties * Group：multi-data-ids * 配置内容示例： * spring.redis.host=localhost * spring.redis.password=20190101 * spring.redis.timeout=5000 * spring.redis.max-idle=5 * spring.redis.max-active=10 * spring.redis.max-wait=3000 * spring.redis.test-on-borrow=false */ @NacosPropertySource(dataId = \"redis.properties\", groupId = \"multi-data-ids\") }) public class NacosConfiguration { } 按照需求我们将数据发布到nacos注册中心上，然后我们进行应用的启动，观察是否可以启动成功。 redis和mysql如果有需要的话，我们还可以按照我们先前教的使用Docker来进行安装，也会省去很多的麻烦。 docker run -p 6379:6379 --name some-redis -d redis 然后我们配置并启动，后进行观察。 注意在启动的时候，数据库的依赖要和连接驱动的版本一致。 这个主要是通过配置文件控制是否开启缓存，与上一个也是类似也不进行多讲，这里主要讲述一个思想，也就是配置是多个数据源，但是是在一个分组里面，比如像Redis等一系列通用的配置是可以放在一个分组里面进行重复使用的。 而多数据源正式通过注解实现的@NacosPropertySources，这个注解里面可以存放来自不同数据源的配置信息，之后如果使用nacos的时候可能会很常用到。对于一些比较雷同的配置就不去做过多的解释了，如果有不懂的话可以在评论区进行留言，看到的话会进行回复。 "}}