# Summary

- Spring AOP 总览
  - [知识储备](Chapter1/1.1.md)
  - [AOP引入：OOP存在的局限性](Chapter1/1.2.md)
  - [AOP使用场景](Chapter1/1.3.md)
  - [AOP概念：Aspect、Join Point和Advice等术语理解](Chapter1/1.4.md)
  - [Java AOP 设计模式：代理、判断和拦截器模式](Chapter1/1.5.md)
  - [Java AOP 代理模式（Proxy）: Java静态代理和动态代理的区别是什么](Chapter1/1.6.md)
  - [Java AOP 判断模式（Predicate）: 如何筛选Join Point](Chapter1/1.7.md)
  - Java AOP 拦截器模式（Interceptor）: 拦截执行分别代表什么
  - Spring AOP 功能概述：核心特性、编程模型和使用限制
  - Spring AOP 编程模型：注解驱动、XML配置驱动和底层API
  - Spring AOP 设计目标：Spring AOP 与 AOP框架之间的关系是竞争还是互补
  - Spring AOP Advice类型:Spring AOP丰富了哪些AOP Advice 呢?
  - Spring AOP代理实现:为什么Spring Framework选择三种不同AOP 实现?
  - JDK动态代理:为什么Proxy.newProxyInstance会生成新的字节码?
  - CGLIB动态代理:为什么Java动态代理无法满定AOP的需要?
  - AspectJ 代理︰为什么Spring推荐AspectJ注解?
  - AspectJ基础: Aspect、Join Points、Pointcuts和Advice语法和特性
  - AspectJ注解驱动:注解能完全替代AspectJ语言吗?
  - 面试
- Spring AOP 基础
- Spring AOP API 设计与实现
- Spring对设计模式的应用
- 综合运用章节 

