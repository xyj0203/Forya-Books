# Summary

- Spring AOP 总览
  - [知识储备](Chapter1/1.1.md)
  - [AOP引入：OOP存在的局限性](Chapter1/1.2.md)
  - [AOP使用场景](Chapter1/1.3.md)
  - [AOP概念：Aspect、Join Point和Advice等术语理解](Chapter1/1.4.md)
  - [Java AOP 设计模式：代理、判断和拦截器模式](Chapter1/1.5.md)
  - [Java AOP 代理模式（Proxy）: Java静态代理和动态代理的区别是什么](Chapter1/1.6.md)
  - [Java AOP 判断模式（Predicate）: 如何筛选Join Point](Chapter1/1.7.md)
  - [Java AOP 拦截器模式（Interceptor）: 拦截执行分别代表什么](Chapter1/1.8.md)
  - [Spring AOP 功能概述：核心特性、编程模型和使用限制](Chapter1/1.9.md)
  - [Spring AOP 编程模型：注解驱动、XML配置驱动和底层API](Chapter1/1.10.md)
  - [Spring AOP Advice类型:Spring AOP丰富了哪些AOP Advice 呢?](Chapter1/1.11.md)
  - [Spring AOP代理实现:为什么Spring Framework选择三种不同AOP 实现?](Chapter1/1.12.md)
  - [JDK动态代理:为什么Proxy.newProxyInstance会生成新的字节码?](Chapter1/1.13.md)
  - [CGLIB动态代理:为什么Java动态代理无法满定AOP的需要?](Chapter1/1.14.md)
  - [面试](Chapter1/1.15.md)
- Spring AOP 基础
  - [@AspectJ注解创建代理](Chapter2/2.1.md)
  - [编程方式创建@AspectJ代理](Chapter2/2.2.md)
  - [XML 配置驱动 - 创建AOP代理](Chapter2/2.3.md)
  - [标准代理工厂API](Chapter2/2.4.md)
  - [@AspectJ Pointcut 指令与表达式](Chapter2/2.5.md)
  - [XML配置Pointcut](Chapter2/2.6.md)
  - [API实现Pointcut](Chapter2/2.7.md)
  - [API 实现 Around Advice](Chapter2/2.8.md)
  - [@AspectJ 前置动作](Chapter2/2.9.md)
  - [Before Advice](Chapter2/2.10.md)
  - [@AspectJ 后置动作](Chapter2/2.11.md)
  - [自动动态代理](Chapter2/2.12.md)
- Spring AOP API 设计与实现
- Spring对设计模式的应用
- 综合运用章节 

